import re

from evaluate import load

from lm_eval.base import Task

import pandas as pd
class StrategyQA(Task):
    """A task represents an entire benchmark including its dataset, problems,
    answers, generation settings and evaluation methods.
    """

    DATASET_PATH = "data/strategy_qa"

    def __init__(self, postprocessed_output_path, sft):
        self.postprocessed_output_path = postprocessed_output_path
        self.sft = sft
        super().__init__(
            requires_execution=True,
        )

    def get_dataset(self):
        """Returns dataset for the task or an iterable of any object, that get_prompt can handle"""
        # dataset = self.dataset["validation"]
        dataset = self.dataset["test"]
        # the wrong split of strategy_qa can be loaded with old datasets cache
        assert (
            # len(dataset) == 319
            len(dataset) == 687
        ), "please ensure you have the latest version of strategy_qa dataset, try deleting its old cache"
        return dataset

    def get_reference(self, doc):
        """Builds the reference solution for the doc (sample from the test dataset)."""
        return "".join(doc["label"])

    def postprocess_generation(self, generation):
        """
        Process the responses generated by the model for true or false questions (yes/no questions)
        :param generation: str
        The response text generated by the model
        """
        completion = generation[0].lower().strip()
        completion = completion[:completion.find('\nquestion:')]
        answer_key = "None"
        
        # SFT mode processing
        answer_begin_hints = [
            "answer is", "answer to", "the answer is", "my answer is", 
            "i would answer", "answer would be", "answer seems to be", 
            "the correct answer is", "answer to the question is",
            "conclusion is", "conclusion would be", "i conclude", "i think" ,"to answer the question","answer: "
        ]
        answer_end_hints = [
            "is the correct answer", "is the answer", "is correct", 
            "is the right answer", "is my answer", "is the conclusion"
        ]
        error = False
        lines = completion.strip().split("\n")
        # lines = lines[::-1]  # Search from back to front

        for line_idx in range(len(lines)):
            line = lines[line_idx]
            matched_begin_hints = [_ for _ in answer_begin_hints if _ in line]
            matched_end_hints = [_ for _ in answer_end_hints if _ in line]
            if len(matched_begin_hints) > 0 and len(matched_end_hints) > 0:
                print("=" * 25 + "Too much matched hints" + "=" * 25)
                # Extract the answer sentence
                hint = matched_begin_hints[0]
                answer_part = line.split(hint)[1].strip()
                if len(answer_part) < 3 and line_idx + 1 < len(lines):
                    answer_part += " " + lines[line_idx + 1]
                # Check yes/no
                words = re.findall(r'\b\w+\b', answer_part.lower())
                if "yes" in words or "true" in words:
                    answer_key = "yes"
                    break
                elif "no" in words or "false" in words:
                    answer_key = "no"
                    break
            elif len(matched_begin_hints) == 0 and len(matched_end_hints) == 0:
                continue
            elif len(matched_begin_hints) >= 1:
                # Extract the answer sentence
                hint = matched_begin_hints[0]
                answer_part = line.split(hint)[1].strip()
                if len(answer_part) < 3 and line_idx + 1 < len(lines):
                    answer_part += " " + lines[line_idx + 1]
                # Check yes/no
                words = re.findall(r'\b\w+\b', answer_part.lower())
                for word in words:
                    if word in ["yes","true"]:
                        answer_key = "yes"
                        break
                    elif word in ["no","false"]:
                        answer_key = "no"
                        break
                if answer_key != "None":
                    break
            elif len(matched_end_hints) >= 1:
                # Extract the answer sentence
                hint = matched_end_hints[0]
                answer_part = line.split(hint)[0].strip()
                # Check yes/no
                words = re.findall(r'\b\w+\b', answer_part.lower())
                if "yes" in words or "true" in words:
                    answer_key = "yes"
                    break
                elif "no" in words or "false" in words:
                    answer_key = "no"
                    break
                
        # If the above method doesn't find the answer, try directly searching for yes/no
        if answer_key == "None":
            # First, check if there is a clear expression
            yes_patterns = [
                r"(?:answer|conclusion) (?:is|would be) yes", 
                r"(?:answer|conclusion) (?:is|would be) true",
                r"(?:yes|true)[,\.]? (?:the answer|that is|this is) (?:correct|right)",
                r"i (?:think|believe|conclude) (?:the answer is )?yes"
            ]
            no_patterns = [
                r"(?:answer|conclusion) (?:is|would be) no", 
                r"(?:answer|conclusion) (?:is|would be) false",
                r"(?:no|false)[,\.]? (?:the answer|that is|this is) (?:correct|right)",
                r"i (?:think|believe|conclude) (?:the answer is )?no"
            ]
            for pattern in yes_patterns:
                if re.search(pattern, completion, re.IGNORECASE):
                    answer_key = "yes"
                    break
            if answer_key == "None":  # If you can't find "yes", then look for "no"
                for pattern in no_patterns:
                    if re.search(pattern, completion, re.IGNORECASE):
                        answer_key = "no"
                        break
                    
        # If you still can't find it, try simply counting the occurrence times of "yes" and "no"
        if answer_key == "None":
            # Word segmentation and statistics
            words = re.findall(r'\b\w+\b', completion.lower())
            yes_count = words.count("yes") + words.count("true")
            no_count = words.count("no") + words.count("false")
            if yes_count > no_count and yes_count > 0:
                answer_key = "yes"
            elif no_count > yes_count and no_count > 0:
                answer_key = "no"
            else:
                print("=" * 25 + "No clear yes or no results" + "=" * 25)
                print(completion)
                print("=" * 120 + "\n\n")
        return completion,answer_key


    def process_results(self, generations, references):
        """Takes the list of LM generations and evaluates them against ground truth references,
        returning the metric for the generations.
        :param generations: list(list(str))
            list of lists containing generations
        :param references: list(str)
            list of str containing refrences
        """
        results = [self.postprocess_generation(_) for _ in generations]
        fixed_generations, generations = zip(*results)
        # If it needs to be converted to a list
        fixed_generations = list(fixed_generations)
        generations = list(generations)

        acc_metric = load("./eval_metric/exact_match")
        is_correct = []
        for ref, gen,_ in zip(references, generations,fixed_generations):
            result = int(acc_metric.compute(
                references=[ref],
                predictions=[gen]
            ) ['exact_match'])
            is_correct.append(result)

        return sum(is_correct)/len(is_correct),fixed_generations,is_correct
